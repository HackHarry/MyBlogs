## 计算机中的数字编码

在现实生活中，我们用的数字通常都是十进制的，但其实十进制的数字在计算机内部不容易表示，更多的是使用二进制。本文旨在介绍计算机存储数值的编码，以及选择这些编码的理由。

首先我们来看一个十进制数6，转换成二进制为110，这就可以存在计算机里了。但是再看-6，转换成二进制为-110，负号是没法存在计算机里的，这该怎么办呢？有一个办法，可以把正负号符号化，正号为0，负号为1，这样一来，+6在计算机里可以用0110表示，-6可以用1110表示。这种编码表示就是**原码表示法**。

对于计算机来说，一个数的长度用字长来表示，基本是固定的，例如8位字长的二进制数，约定最高位作为符号位，剩下7位用来表示数值，高位补0，如-2的原码为1000 0010。因此，在做原码加减法运算时，符号位单独判断，来决定数值部分进行绝对值的加减法运算，然后根据绝对值的大小决定结果的符号。例如，-6+4，两个数符号不同，进行绝对值相减，0110-0100=0010，然后判断符号为负号，因此结果为1010，也就是-2。

但是，对于人脑来说判断符号来确定加减很容易，对于电脑来说却要多出很多复杂的步骤。所以人们有两个需求：1.符号位参与运算；2.减法运算变成加法运算。除此之外，需要注意的是0的原码有两个，+0和-0。

前面提到，计算机中一个数的长度用字长来表示，那么如果超过表示范围的数就会溢出。这其实是一种模运算。以表盘时钟举例，6点过8个小时后，时针指向的时间是2点，实际上这个2是6+8的和除以12的余数，因为14溢出了12的表示范围。因此如果要把6点变成2点，有两种方法，一种是往后拨4个小时，一种是往前拨8个小时，即2=6-4=6+8。也就是说，这提供了模运算中将减法变成加法的一种方法，特别能关注到，4和8的和就是12。因此，我们提出了新的编码方式——**反码表示法**。

虽然上面4对应的数是8，但是原码有两个0，因此，n位二进制不能用2^n来作为求对应数的模，而应该减去1，其结果也应该加上1。简便起见，以字长为4举例，我们不能用16来作为模，而是用15，故3-2=3+13，13的二进制为1101，3的二进制为0011，1101+0011=0000，也就是0，加上1后就是需要求的值了。这种方法同时也把符号位参与了运算，解决了两个需求。可以看到，正数的反码不需要变化，和原码一样就可以了，而负数-2的原码为1010，13的二进制为1101，恰好是除符号位外全部取反，因此这种编码叫做反码。

但可以看到，反码运算虽然不用判断符号位了，但因为+0和-0的存在，使得运算时还要-1或+1，很麻烦，因此我们需要进一步优化编码方式。先思考一下如何解决0有两个编码的问题，简单粗暴的方法就是，负数的反码全都加上1。我们来看看+1之后会变成什么样。依然以上文中3-2举例，-2的反码为1101，+1之后为1110，1110+0011=0001，刚好就是答案1，而原来表示-0的编码1111变成-1的编码了，因此表示范围下限也扩大了1个。正因为这种方法是对反码的补充，因此，这种编码方式叫做——**补码表示法**。

到此，三种基本编码方式的前世今生都差不多理清楚了。总结一下：正数的三种编码方式的值都是一样的；负数的反码是原码除了符号位以外全部取反，补码是反码再加一。

但是，到目前为止提到的运算都是基于整数的，实际中还有小数需要处理，在下一篇系列文章中将会介绍小数的存储方式。