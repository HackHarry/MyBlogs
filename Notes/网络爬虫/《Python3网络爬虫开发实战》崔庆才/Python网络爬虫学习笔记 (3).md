## Python爬虫学习笔记（三）——正则表达式

### 介绍

正则表达式是一种处理字符串的强大工具，能实现字符串的检索、替换、匹配验证等。在爬虫中，正则表达式主要用于从HTML里提取所需要的信息

### 常用的匹配规则
| 模式   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| \w     | 匹配字母、数字及下划线                                       |
| \W     | 匹配不是字母、数字及下划线的字符                             |
| \s     | 匹配任意空白字符，等价于[\t\n\r\f]                           |
| \S     | 匹配任意非空字符                                             |
| \d     | 匹配任意数字，等价于[0-9]                                    |
| \D     | 匹配任意非数字的字符                                         |
| \A     | 匹配字符串开头                                               |
| \Z     | 匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串     |
| \z     | 匹配字符串结尾，如果存在换行，同时还会匹配换行符             |
| \G     | 匹配最后匹配完成的位置                                       |
| \n     | 匹配一个换行符                                               |
| \t     | 匹配一一个制表符                                             |
| ^      | 匹配一行字符串的开头                                         |
| $      | 匹配一行字符串的结尾                                         |
| .      | 匹配任意字符，除了换行符，当re.DOTALL 标记被指定时，则可以匹配包括换行符的任意字符 |
| [...]  | 用来表示一一组字符，单独列出，比如[amk]匹配a、 m或k          |
| [^...] | 不在[]中的字符，比如[^abc]匹配除了 a、b、c之外的字符         |
| *      | 匹配0个或多个表达式                                          |
| +      | 匹配1个或多个表达式                                          |
| ?      | 匹配0个或1个前面的正则表达式定义的片段，非贪婪方式           |
| {n}    | 精确匹配n个前面的表达式                                      |
| {n,m}  | 匹配n到m次由前面正则表达式定义的片段，贪婪方式               |
| a\|b   | 匹配a或b                                                     |
| ()     | 匹配括号内的表达式，也表示一个组                             |

### 常用方法
**match()**
向它传入要匹配的字符串以及正则表达式，就可以检测这个正则表达式是否匹配字符串。这个方法会从字符串的起始位置开始匹配，如果不匹配，返回None。因为该方法在使用时需要考虑开头的内容，这在做匹配时并不方便，因此更适合用来判断某个字符串是否符合某个正则表达式。
示例如下：

```
import re

content = 'Hello 1234567 World_This is a Regex Demo'
result = re.match('^He.*?(\d+).*Demo$',content)
print(result.group(1))
```
上述代码涉及到贪婪匹配和非贪婪匹配，这个到后面在介绍
**search()**
这个方法与上一个方法的不同之处在于，它在匹配时会扫描整个字符串，然后返回第一个成功匹配的结果。换句话说，正则表达式是整个字符串的子串。如果没有匹配的，就会返回None。

**findall()**
search()只能返回第一个匹配成功的结果，但有时候我们需要所有结果，这时候就可以用findall()方法了。该方法可以搜索整个字符串，然后返回匹配正则表达式的所有内容。

**sub()**
这个方法主要是用来修改文本。示例如下：
```
import re

content = 'fgah32jsehi543dasdf342'
content = re.sub('\d+\, '', content)
print(content)
```
这里sub()就是把所有的数字删除，返回结果为hjsehidasdf
此外，sub()还可以用来删去字符串中干扰匹配的字符，以此来简化匹配
**compile()**
书上介绍这个方法可以将正则表达式编译成正则表达式对象，以便在后面的匹配中复用。但我不是很理解正则表达式对象这一说法，如果单纯用字符串存正则表达式也不是不可以，这个还有待进一步的探究。

### 其它
**贪婪与非贪婪**
贪婪匹配模式下，.*会匹配尽可能多的字符，有时候会让匹配少了一部分内容。非贪婪模式的写法就是.*?。示例如下：
```
import re

content = 'Hello 1234567 World_This is a Regex Demo'
regex = '^He.*?(\d+).*Demo$'
result1 = re.match('^He.*(\d+).*Demo$', content)
result2 = re.match('^He.*?(\d+).*Demo$', content)
print(result1.group(1))
print(result2.group(1))
```
返回结果为
```
7
1234567
```
从这个代码中就可以看出贪婪和非贪婪的区别了

**修饰符**
正则表达式可以包含一些可选标志修饰符来控制匹配的模式

| 修饰符 | 描述                                                       |
| ------ | ---------------------------------------------------------- |
| re.I   | 使匹配对大小写不敏感                                       |
| re.L   | 做本地化识别匹配                                           |
| re.M   | 多行匹配，影响^和$                                         |
| re.S   | 使.匹配包括换行在内的所有字符                              |
| re.U   | 根据Unicode字符集解析字符，影响\w、\W、\b和\B              |
| re.X   | 该标志通过给予更灵活的格式以便你将正则表达式写得更易于理解 |

**转义匹配**
正则表达式定义了许多匹配模式，但如果目标字符串里就包含对应语法的字符，就需要用转义匹配了。类似于markdown语法，在所需要转义的字符前加上反斜杠就好。

### 总结
正则表达式是第三章知识点的最后一节了，以所学的内容应该可以实现基本爬虫了。我打算明天做一个小项目，按照书上的建议，大概是爬取猫眼电影排行榜吧。