## 位运算的一些技巧

这几天，我在家刷《剑指offer》里的算法题，碰到了一道关于位运算的有趣问题。

> 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 

题目很简单也很短，但是却有好几个坑在里面。至于有什么坑，且看下去。

#### 分析

首先要知道，负数在计算机里就是以补码的形式存在的，所以不需要考虑如何将负数用补码表示。因此，第一次遇到这种问题，最直接的想法就是每次将该数与1进行与运算，然后再右移，这样循环下去。代码很简单，如下。

```c++
int NumberOf1(int n) {
	int count = 0;
	while(n) {
		if(n & 1) count++;
		n = n >> 1;
	}
	return count;
}
```

但是实际上，这种解法只能解决正数的问题，负数会导致死循环。这是为什么呢？我们来看一下负数会是什么情况。

我们知道，负数是用补码表示的，最高位是1。那么如果右移一位，为了保证依然是个负数，最高位还是补1。接下来举个例子就很容易明白了。例如，0x8000_0000，右移一位后不是变成0x4000_0000，而是变成了0xC000_0000。如果一直做右移运算，最终结果会变成0xFFFF_FFFF，也就是-1，从而陷入了死循环。因此，右移是不能解决这个问题的。

#### 解法一

通过具体的负数例子，我们知道了负数一直右移是不会变成0的，最终结果会是-1，这也是补码表示法为了多表示一个数带来的副作用。既然右移不可以，那么左移可不可以呢？当然是可以的。我们可以每次将做与运算的数左移一位，例如从1B变成10B、100B……，这样就避免了负数右移陷入死循环的问题了。代码如下：

```c++
int NumberOf1(int n) {
	int count = 0;
	unsigned int flag = 1;
	while(flag) {
		if(n & flag) count++;
		flag = flag << 1;
	}
	return count;
}
```

这个算法已经非常简单了，不过还是有一个小问题。我们是不知道flag要左移几次的，只能一直左移下去，直到溢出变成0，也就是说32位整数就必须要做32次循环，但实际上很多数都不需要判断那么多次。

#### 解法二

那么有没有更优秀的解决方案呢？当然是有的。

这回我们不先讲述思路了，而是先把代码贴出来。

```c++
int NumberOf1(int n) {
    int count = 0;
    while(n) {
        count++;
        n = n & (n-1);
    }
    return count;
}
```

代码非常简短，但是却不容易看懂。最关键的部分在于`n = n & (n-1)`，刚看到这段代码肯定会觉得奇怪，为什么要将n和n-1进行与运算呢？我们进行一些实际的计算就知道了。

以1100B为例，1100 - 1 = 1011，然后用1100和1011进行与运算，结果是1000。发现了吗？没发现的话，我们再来看个例子。以1010B为例，1010 - 1 = 1001，1001与1010进行与运算，结果是1000。

根据这些例子，可以总结出一个规律：

> 把一个整数减去1之后再与原来的整数做位与运算，得到的结果相当于是把整数的二进制表示中的最右边的一个1变成0。

根据这个规律，我们就可以得出上面的代码了。

#### 总结

位运算的用处说大不大，说小也不小。常见的用法有判断奇偶数、优化乘除法等，此外就是例如上题这样跟进制有关的问题了。

不过虽然在学语言的时候，老师都会强调位运算对于代码性能的优化，可相应的，位运算也会使得代码变得难读，不方便后续的维护和修改。实际上，大多数编译器都会自动对乘除取余等运算进行优化，将其变为位运算的形式。我随意测试了一下，有无用位运算优化的代码实际性能是差不多的。

因此，我个人感觉没必要在写代码时候强求位运算的奇技淫巧，不如追求可读性直接写乘除。

#### 番外

说到位运算的奇妙操作，我想起了高中信息奥赛时遇到的一个问题，也非常有趣。

> 现有5堆石子，石子数依次为3,5,7,19,50，甲乙两人轮流从任一堆中任取（每次只能取自一堆,不能不取），取最后一颗石子的一方获胜。甲先取,问甲有没有获胜策略（即无论乙怎样取,甲只要不失误,都能获胜）？如果有，甲第一步应该在哪一堆里取多少？  

这类问题本质当然是保证自己每次都处于必胜状态，解题的关键在于异或运算。网上有非常多的分析，我就不再赘述了，大家可以自己玩玩看。

